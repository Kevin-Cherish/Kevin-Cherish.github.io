---
title: python gc 垃圾回收
date: 2019-11-21 14:58:54
tags:
- python
---

## 概述
Python垃圾回收机制（Garbage Collection）原理：
python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。

<!-- more -->
## python 中的GC算法
### 引用计数
python 一切皆对象，python 中每一个对象在底层都是都是一个由C定义的结构体Py_Object,所有object都包含这样一个头部
```c
// object.h
struct _object {
    Py_ssize_t ob_refcnt;  # 引用计数值
    struct PyTypeObject *ob_type;
} PyObject;
```
其中ob_refcnt就是引用计数器，当新创建一个对象时，ob_refcnt的值就会加1，当引用它的对象被删除就会减1，当应用计数器的值为0的时候，该对象的生命周期就结束了

引用计数的优点是 
- 简单,一旦对象不再被引用，就会被释放掉（be freed）

缺点：
- 维护引用计数消耗资源，每一次引用赋值都会维护一次引用计数
- 无法解决循环引用的问题。比如
```python
l = []
l.append(l)
del l
```

循环引用：存在一组未使用、互相指向的对象，但是这组对象都没有外部引用，即在程序中不会再使用这些对象，所以希望Python的垃圾回收机制能够去释放这些对象所占用的内存空间，但由于这些对象的引用计数为1并不是0，又不能去触发释放操作。

### 标记清除 mark-sweep

标记清除是一种基于追踪回收计数实现的的算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的“活动对象”打上标记，第二阶段是把那些没有标记对象的“非活动对象”进行回收。基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。


下面引用《[Python内存管理机制及优化简析](http://kkpattern.github.io/2015/06/20/python-memory-optimization-zh.html)》

>　　在Python中, 所有能够引用其他对象的对象都被称为容器(container). 因此只有容器之间才可能形成循环引用. Python的垃圾回收机制利用了这个特点来寻找需要被释放的对象. 为了记录下所有的容器对象, Python将每一个 容器都链到了一个双向链表中, 之所以使用双向链表是为了方便快速的在容器集合中插入和删除对象. 有了这个 维护了所有容器对象的双向链表以后, Python在垃圾回收时使用如下步骤来寻找需要释放的对象:
>
>　　1.对于每一个容器对象, 设置一个gc_refs值, 并将其初始化为该对象的引用计数值.
>　　2.对于每一个容器对象, 找到所有其引用的对象, 将被引用对象的gc_refs值减1.
>　　3.执行完步骤2以后所有gc_refs值还大于0的对象都被非容器对象引用着, 至少存在一个非循环引用. 因此 不能释放这些对象, 将他们放入另一个集合.
>　　4.在步骤3中不能被释放的对象, 如果他们引用着某个对象, 被引用的对象也是不能被释放的, 因此将这些 对象也放入另一个集合中.
>　　5.此时还剩下的对象都是无法到达的对象. 现在可以释放这些对象了.

### 分代算法 generational

> 　　除此之外, Python还将所有对象根据’生存时间’分为3代, 从0到2. 所有新创建的对象都分配为第0代. 当这些对象 经过一次垃圾回收仍然存在则会被放入第1代中. 如果第1代中的对象在一次垃圾回收之后仍然存货则被放入第2代. 对于不同代的对象Python的回收的频率也不一样. 可以通过`gc.set_threshold(threshold0[, threshold1[, threshold2]])` 来定义. 当Python的垃圾回收器中新增的对象数量减去删除的对象数量大于threshold0时, Python会对第0代对象 执行一次垃圾回收. 每当第0代被检查的次数超过了threshold1时, 第1代对象就会被执行一次垃圾回收. 同理每当 第1代被检查的次数超过了threshold2时, 第2代对象也会被执行一次垃圾回收.

## gc 模块
　　此模块提供可选垃圾收集器的接口。它提供了禁用收集器、调整收集频率和设置调试选项的功能。它还提供对收集器找到但无法释放的无法访问对象的访问。由于收集器补充了Python中已经使用的引用计数，因此如果您确定程序没有创建引用循环，则可以禁用收集器。

### gc.enable()
　　开启gc（默认情况下是开启的）
### gc.disable()
　　关闭gc
### gc.isenable()
　　判断gc是否开启
### gc.collect(generation=None)
　　没有参数时，全回收。

