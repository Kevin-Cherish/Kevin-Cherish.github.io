<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cherish-kevin</title>
  
  <subtitle>学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-21T13:23:41.081Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>dli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python-gil</title>
    <link href="http://yoursite.com/2021/01/21/python-gil/"/>
    <id>http://yoursite.com/2021/01/21/python-gil/</id>
    <published>2021-01-21T09:30:22.000Z</published>
    <updated>2021-01-21T13:23:41.081Z</updated>
    
    <content type="html"><![CDATA[<p>在 Cpython 中，全局解释器锁 GIL（Global Interpreter Lock）是一个 mutex, 它保证多线程环境下只有一个线程可以执行python字节码。</p><a id="more"></a><p>Q：GIL 为什么是 mutex？</p><p>A：因为 Cpython 的内存管理不是线程安全的，GIL保证了任何时刻都只有一个线程在运行。</p><p>Q：何时释放GIL？</p><p>A: 在进行IO操作时，python解析器会释放GIL，但IO操作结束之后，必须获取GIL才能继续运行。在python3.2之前， 基于tick计数器进行GIL，tick计数器表示当前线程在释放gil之前连续执行的多少个字节码，一个已经获取GIL的线程在tick到达100之后释放 GIL，给其它线程获取GIL的机会。python3.2之后，基于时间片释放 GIL, 默认间隔 <code>DEFAULT_INTERVAL=5000</code> 0.5秒</p><p>Q: 如何解决GIL？</p><p>A: C语言扩展，多进程，其它语言编译的解释器（<code>Jpython</code>, <code>LronPython</code>）。</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ol><li>多进程可以使用多核CPU</li><li>在多核CPU上，使用CPython解析器的python多线程，当有一个CPU密集型线程存在时，多线程效率由于GIL导致效率下降。</li></ol><p>下面我们就对比下Python在多线程和单线程下得效率对比，测试代码如下:</p><h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">count = <span class="number">100000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(c)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> c &gt; <span class="number">0</span>:</span><br><span class="line">        c -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">t1 = time.time()</span><br><span class="line">foo(count)</span><br><span class="line">print(time.time() - t1)  <span class="comment"># 5.546911001205444</span></span><br></pre></td></tr></table></figure><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">count = <span class="number">100000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(c)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> c &gt; <span class="number">0</span>:</span><br><span class="line">        c -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">t1 = time.time()</span><br><span class="line">thread1 = threading.Thread(target=foo, args=(count // <span class="number">2</span>,))</span><br><span class="line">thread2 = threading.Thread(target=foo, args=(count // <span class="number">2</span>,))</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">print(time.time() - t1)  <span class="comment"># 5.651936054229736</span></span><br></pre></td></tr></table></figure><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line">count = <span class="number">100000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(c)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> c &gt; <span class="number">0</span>:</span><br><span class="line">        c -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">t1 = time.time()</span><br><span class="line">mp1 = mp.Process(target=foo, args=(count // <span class="number">2</span>,))</span><br><span class="line">mp2 = mp.Process(target=foo, args=(count // <span class="number">2</span>,))</span><br><span class="line">mp1.start()</span><br><span class="line">mp2.start()</span><br><span class="line">mp1.join()</span><br><span class="line">mp2.join()</span><br><span class="line"></span><br><span class="line">print(time.time() - t1)  <span class="comment"># 2.8516108989715576</span></span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/gil/gil_cn.md" target="_blank" rel="noopener">https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/gil/gil_cn.md</a></li><li><a href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="noopener">https://wiki.python.org/moin/GlobalInterpreterLock</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Cpython 中，全局解释器锁 GIL（Global Interpreter Lock）是一个 mutex, 它保证多线程环境下只有一个线程可以执行python字节码。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Spin Lock</title>
    <link href="http://yoursite.com/2020/04/19/spin-lock/"/>
    <id>http://yoursite.com/2020/04/19/spin-lock/</id>
    <published>2020-04-19T04:02:23.000Z</published>
    <updated>2021-01-17T11:04:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>spin lock是一种锁，使用它的线程在循环中简单地等待（“spin”），同时重复检查锁是否可用</p><a id="more"></a><p>理论上，当一个线程访问一个已经被被锁定(mutex)的临界区资源时，它将进入睡眠状态。因为这种操作比较费时，完成这些操作时，其它线程可能已经释放了锁。</p><p>在这些情况下，多处理系统使用了spin lock。当一个线程发现临界区资源被另外的线程锁着时，它将不断“旋转”，直到资源释放，在这期间，该线程始终处于运行态(但是， 一旦超过了当前线程的CPU时间片，操作系统将强制切换到另一个线程。)</p><p>在多核/多CPU系统中，如果大量的锁只保留很短的时间，那么不断的让线程进入睡眠状态并唤醒它们所浪费的时间可能会显著降低运行性能。当使用自旋锁时，线程总是在很短的时间内阻塞，但随后立即继续工作，从而获得更高的处理吞吐量。</p><p>在单处理环境下，spin lock 是无效的，因为轮询 spin lock将阻塞了唯一可用的cup内核，就没有其他线程可以运行，也就没有机会释放这个自旋锁。在这些系统中使用spin lock 只会浪费CPU时间，不会有任何好处。</p><p>hybrid mutex: 在多核系统中，混合互斥锁的行为起初类似于自旋锁。如果线程无法锁定mutex，它不会立即进入睡眠状态，因为互斥锁可能很快就会被解锁，因此互斥锁首先的行为将与自旋锁完全相同。只有在经过一定时间仍未获得锁时，线程才会真正进入睡眠状态。</p><p>Reference:</p><ul><li>深入理解Linux内核 （31p）</li><li><a href="https://mail.python.org/pipermail/python-ideas/2010-July/007645.html" target="_blank" rel="noopener">https://mail.python.org/pipermail/python-ideas/2010-July/007645.html</a></li><li><a href="https://stackoverflow.com/questions/5869825/when-should-one-use-a-spinlock-instead-of-mutex" target="_blank" rel="noopener">https://stackoverflow.com/questions/5869825/when-should-one-use-a-spinlock-instead-of-mutex</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;spin lock是一种锁，使用它的线程在循环中简单地等待（“spin”），同时重复检查锁是否可用&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="lock" scheme="http://yoursite.com/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>zlib，gzip快速识别</title>
    <link href="http://yoursite.com/2019/11/25/zlib/"/>
    <id>http://yoursite.com/2019/11/25/zlib/</id>
    <published>2019-11-25T09:40:38.000Z</published>
    <updated>2021-01-21T10:56:14.316Z</updated>
    
    <content type="html"><![CDATA[<p>在写爬虫时，会遇到各种各样的压缩算法，快速识别各种压缩算法可以节省时间，本文将介绍两种压缩算法。<br><a id="more"></a></p><h2 id="zlib压缩数据格式"><a href="#zlib压缩数据格式" class="headerlink" title="zlib压缩数据格式"></a>zlib压缩数据格式</h2><p><img src="/images/zlib.png" alt></p><h3 id="CMF（Compression-Method-and-flags）"><a href="#CMF（Compression-Method-and-flags）" class="headerlink" title="CMF（Compression Method and flags）:"></a>CMF（Compression Method and flags）:</h3><p>0~3bit CM 压缩方法。<br>4~7bit CNIFO 压缩信息。<br>目前只有deflate(CM=8)算法。对于CM=8，CNIFO几乎不会设置7以外的任何值，因此CMF常见数值为0x78</p><h3 id="FLG-FLaGs"><a href="#FLG-FLaGs" class="headerlink" title="FLG (FLaGs) :"></a>FLG (FLaGs) :</h3><p>0~4bit FCHECK 检测位。FLEVEL和FDICT确定之后计算FCHECK。最后（CMF * 256 + FLG）是31的倍数<br>5bit  FDICT<br>6~7bit FLEVEL 压缩等级。  </p><h3 id="FLEVEL-compress-level"><a href="#FLEVEL-compress-level" class="headerlink" title="FLEVEL (compress level)"></a>FLEVEL (compress level)</h3><p>不同的压缩算法有不同的等级。deflate（CM=8）算法压缩等级如下<br> 　　0 - 最快压缩<br> 　　1 - 快压缩<br> 　　2 - 默认压缩<br> 　　3 - 最大压缩率，最慢速度  </p><h3 id="常用头部"><a href="#常用头部" class="headerlink" title="常用头部"></a>常用头部</h3><div class="table-container"><table><thead><tr><th style="text-align:center">CMF</th><th style="text-align:center">FLG</th></tr></thead><tbody><tr><td style="text-align:center">0x78</td><td style="text-align:center">0x01 - No Compression/low</td></tr><tr><td style="text-align:center">0x78</td><td style="text-align:center">0x5e - Fast Compression</td></tr><tr><td style="text-align:center">0x78</td><td style="text-align:center">0x9C - Default Compression</td></tr><tr><td style="text-align:center">0x78</td><td style="text-align:center">0xDA - Best Compression</td></tr></tbody></table></div><p><font color="red"> \x78\x79 </font>最常见</p><h2 id="gzib-压缩数据格式"><a href="#gzib-压缩数据格式" class="headerlink" title="gzib 压缩数据格式"></a>gzib 压缩数据格式</h2><p><img src="/images/gzip.png" alt></p><h3 id="ID1和ID2"><a href="#ID1和ID2" class="headerlink" title="ID1和ID2"></a>ID1和ID2</h3><p>确定一个文件为gzip格式的标识，因此ID1和ID2为固定值：ID1 = 31(0x1f)，ID2 = 139(0x8b)</p><h3 id="CM"><a href="#CM" class="headerlink" title="CM"></a>CM</h3><p>目前只有deflate(CM=8)算法</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>因此根据 <font color="red"> \x1f\x8b\x08 </font> 就可以确定这个算法为gzib压缩算法。</p><h2 id="python-zlib模块"><a href="#python-zlib模块" class="headerlink" title="python zlib模块"></a>python zlib模块</h2><p><code>zlib.compress</code>对数据进行 zlib 格式压缩，好像压缩的时候只支持这一种格式，不过你可以通过把压缩后的数据去掉两字节 zlib 头和末尾 4 字节的 CRC 校验得到 deflate 格式的压缩数据（zlib_compressed[2:-4]）</p><p>对于 gzip 压缩格式可以通过 gzip 模块得到。  </p><p><code>zlib.decompress(string[,wbits[,bufsize]])</code> 解压更折腾，压缩格式是通过 <code>wbits</code> 参数控制的：</p><ul><li>[8, 15]：解压 zlib 格式的数据, 必须有头和尾</li><li>[-8, -15]：解压 deflate 格式数据</li><li>[24, 31] = 16 + (8 to 15)：解压 gzip 格式数据</li><li>[40, 47] = 32 + (8 to 15)：zip和gzip都可以</li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://tools.ietf.org/html/rfc1950" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1950</a><br><a href="https://tools.ietf.org/html/rfc1952" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1952</a><br><a href="https://my.oschina.net/u/658658/blog/306777" target="_blank" rel="noopener">https://my.oschina.net/u/658658/blog/306777</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写爬虫时，会遇到各种各样的压缩算法，快速识别各种压缩算法可以节省时间，本文将介绍两种压缩算法。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="zlib" scheme="http://yoursite.com/tags/zlib/"/>
    
      <category term="gzip" scheme="http://yoursite.com/tags/gzip/"/>
    
  </entry>
  
  <entry>
    <title>python gc 垃圾回收</title>
    <link href="http://yoursite.com/2019/11/21/gc/"/>
    <id>http://yoursite.com/2019/11/21/gc/</id>
    <published>2019-11-21T06:58:54.000Z</published>
    <updated>2021-01-17T11:04:05.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Python垃圾回收机制（Garbage Collection）原理：<br>python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。</p><a id="more"></a><h2 id="python-中的GC算法"><a href="#python-中的GC算法" class="headerlink" title="python 中的GC算法"></a>python 中的GC算法</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>python 一切皆对象，python 中每一个对象在底层都是都是一个由C定义的结构体Py_Object,所有object都包含这样一个头部<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;  # 引用计数值</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyTypeObject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure></p><p>其中ob_refcnt就是引用计数器，当新创建一个对象时，ob_refcnt的值就会加1，当引用它的对象被删除就会减1，当应用计数器的值为0的时候，该对象的生命周期就结束了</p><p>引用计数的优点是 </p><ul><li>简单,一旦对象不再被引用，就会被释放掉（be freed）</li></ul><p>缺点：</p><ul><li>维护引用计数消耗资源，每一次引用赋值都会维护一次引用计数</li><li>无法解决循环引用的问题。比如<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line">l.append(l)</span><br><span class="line"><span class="keyword">del</span> l</span><br></pre></td></tr></table></figure></li></ul><p>循环引用：存在一组未使用、互相指向的对象，但是这组对象都没有外部引用，即在程序中不会再使用这些对象，所以希望Python的垃圾回收机制能够去释放这些对象所占用的内存空间，但由于这些对象的引用计数为1并不是0，又不能去触发释放操作。</p><h3 id="标记清除-mark-sweep"><a href="#标记清除-mark-sweep" class="headerlink" title="标记清除 mark-sweep"></a>标记清除 mark-sweep</h3><p>标记清除是一种基于追踪回收计数实现的的算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的“活动对象”打上标记，第二阶段是把那些没有标记对象的“非活动对象”进行回收。基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p><p>下面引用《<a href="http://kkpattern.github.io/2015/06/20/python-memory-optimization-zh.html" target="_blank" rel="noopener">Python内存管理机制及优化简析</a>》</p><blockquote><p>　　在Python中, 所有能够引用其他对象的对象都被称为容器(container). 因此只有容器之间才可能形成循环引用. Python的垃圾回收机制利用了这个特点来寻找需要被释放的对象. 为了记录下所有的容器对象, Python将每一个 容器都链到了一个双向链表中, 之所以使用双向链表是为了方便快速的在容器集合中插入和删除对象. 有了这个 维护了所有容器对象的双向链表以后, Python在垃圾回收时使用如下步骤来寻找需要释放的对象:</p><p>　　1.对于每一个容器对象, 设置一个gc_refs值, 并将其初始化为该对象的引用计数值.<br>　　2.对于每一个容器对象, 找到所有其引用的对象, 将被引用对象的gc_refs值减1.<br>　　3.执行完步骤2以后所有gc_refs值还大于0的对象都被非容器对象引用着, 至少存在一个非循环引用. 因此 不能释放这些对象, 将他们放入另一个集合.<br>　　4.在步骤3中不能被释放的对象, 如果他们引用着某个对象, 被引用的对象也是不能被释放的, 因此将这些 对象也放入另一个集合中.<br>　　5.此时还剩下的对象都是无法到达的对象. 现在可以释放这些对象了.</p></blockquote><h3 id="分代算法-generational"><a href="#分代算法-generational" class="headerlink" title="分代算法 generational"></a>分代算法 generational</h3><blockquote><p>　　除此之外, Python还将所有对象根据’生存时间’分为3代, 从0到2. 所有新创建的对象都分配为第0代. 当这些对象 经过一次垃圾回收仍然存在则会被放入第1代中. 如果第1代中的对象在一次垃圾回收之后仍然存货则被放入第2代. 对于不同代的对象Python的回收的频率也不一样. 可以通过<code>gc.set_threshold(threshold0[, threshold1[, threshold2]])</code> 来定义. 当Python的垃圾回收器中新增的对象数量减去删除的对象数量大于threshold0时, Python会对第0代对象 执行一次垃圾回收. 每当第0代被检查的次数超过了threshold1时, 第1代对象就会被执行一次垃圾回收. 同理每当 第1代被检查的次数超过了threshold2时, 第2代对象也会被执行一次垃圾回收.</p></blockquote><h2 id="gc-模块"><a href="#gc-模块" class="headerlink" title="gc 模块"></a>gc 模块</h2><p>　　此模块提供可选垃圾收集器的接口。它提供了禁用收集器、调整收集频率和设置调试选项的功能。它还提供对收集器找到但无法释放的无法访问对象的访问。由于收集器补充了Python中已经使用的引用计数，因此如果您确定程序没有创建引用循环，则可以禁用收集器。</p><h3 id="gc-enable"><a href="#gc-enable" class="headerlink" title="gc.enable()"></a>gc.enable()</h3><p>　　开启gc（默认情况下是开启的）</p><h3 id="gc-disable"><a href="#gc-disable" class="headerlink" title="gc.disable()"></a>gc.disable()</h3><p>　　关闭gc</p><h3 id="gc-isenable"><a href="#gc-isenable" class="headerlink" title="gc.isenable()"></a>gc.isenable()</h3><p>　　判断gc是否开启</p><h3 id="gc-collect-generation-None"><a href="#gc-collect-generation-None" class="headerlink" title="gc.collect(generation=None)"></a>gc.collect(generation=None)</h3><p>　　没有参数时，全回收。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Python垃圾回收机制（Garbage Collection）原理：&lt;br&gt;python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Random Variables</title>
    <link href="http://yoursite.com/2019/11/10/rv-sums/"/>
    <id>http://yoursite.com/2019/11/10/rv-sums/</id>
    <published>2019-11-10T08:08:23.000Z</published>
    <updated>2021-01-17T11:04:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>本文将展示一个随机变量及其相关的概率分布是如何被统计学描述的，比如均值和方差。</p><a id="more"></a><h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><p>许多情况下，随机变量可以定义为其他随机变量之和。这些情况中最重要的是从样本均值估计总体均值。因此，我们需要一些关于随机变量的性质。</p><h3 id="期望（Expected-Value）"><a href="#期望（Expected-Value）" class="headerlink" title="期望（Expected Value）"></a>期望（Expected Value）</h3><p>离散随机变量和连续随机变量计算公式：</p><ul><li>离散变量$E(X) = \sum xP(x)$</li><li>连续变量$E(X) = \int_{- \infty}^{ + \infty} xf(x)dx$</li></ul><p>几个随机变量加在一起的平均值就是它们的平均值之和，即使不同的变量在统计学上不独立。</p><script type="math/tex; mode=display">E(x)=ax+b</script><p>对于离散情况和连续情况，证明都相当简单。唯一需要了解的是求和（或积分）的顺序可以互换和在证明的中途出现的边缘分布函数。</p><p>离散情况证明：</p><script type="math/tex; mode=display">\begin{equation}\begin{split}   E(X + Y) &= \sum_x \sum_y (x+y) P_{XY}(x,y) \\  &= \sum\limits_x \sum\limits_y x P_{XY}(x,y) + \sum\limits_y \sum\limits_x y P_{XY}(x,y) \\  &= \sum\limits_x x P_X (x) + y P_Y (y) \\  &= E(X) + E(Y)\end{split}\end{equation}</script><p>连续变量证明:</p><script type="math/tex; mode=display">\begin{equation}\begin{split}  E(X + Y) &= \int_x \int_y (x+y) f_{XY}(x,y) \mathrm{d}x \\\\  &= \int_x \int_y x f_{XY}(x,y) \mathrm{d}y \mathrm{d}x + \int_y \int_x y f_{XY}(x,y) \mathrm{d}x \mathrm{d}y \\\\  &= \int_x x f_X (x) \mathrm{d}x + \int_y y f_Y (y) \mathrm{d}y \\\\  &= E(X) + E(Y)\end{split}\end{equation}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将展示一个随机变量及其相关的概率分布是如何被统计学描述的，比如均值和方差。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据分析" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>matplotlib 漏斗图</title>
    <link href="http://yoursite.com/2019/11/05/funnel-charts/"/>
    <id>http://yoursite.com/2019/11/05/funnel-charts/</id>
    <published>2019-11-05T01:27:09.000Z</published>
    <updated>2021-01-17T11:04:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>漏斗（funnel）图通常用于显示流程数据。漏斗图用梯形面积表示某个环节业务量与上一个环节之间的差异。漏斗图从上到下，有逻辑上的顺序关系，表现了随着业务流程的推进业务目标完成的情况。例如，它用于观察每个阶段销售过程中的收入或损失，并显示逐渐减少的值。每个阶段都以占所有值的百分比表示。</p><a id="more"></a><h1 id="matplitlib-画漏斗图"><a href="#matplitlib-画漏斗图" class="headerlink" title="matplitlib 画漏斗图"></a>matplitlib 画漏斗图</h1><ul><li>预备知识：barh, TextArea, AnnotationBbox</li></ul><h2 id="barh"><a href="#barh" class="headerlink" title="barh"></a>barh</h2><p>matplotlib.pyplot.barh(y, width, height=0.8, left=None, <em>, align=’center’, *</em>kwargs)</p><p>Make a horizontal bar plot.</p><ul><li>y: 标量或类数组：条形的y坐标</li><li>width: 标量，条的宽度</li><li>height: 标量，条的高度</li><li>left: 条形图左侧的x坐标</li><li>align: {‘center’, ‘edge’} </li><li>tick_label : 字符串或类似数据，条的刻度标签</li></ul><h2 id="TextAres"><a href="#TextAres" class="headerlink" title="TextAres"></a>TextAres</h2><p>matplotlib.offsetbox.TextArea(s, textprops=None, multilinebaseline=None, minimumdescent=True)</p><p>TextArea包含单个文本实例。文本以基线+左对齐方式放置在（0,0）处。TextArea实例的宽度和高度是其子文本的宽度和高度。</p><ul><li>s : 字符串，显示的文本</li><li>textprops: 字典，显示的文本的格式</li><li>multilinebaseline: bool, 如果为True，则对多行文本的基线进行调整，使其与单线文本对齐（近似）。</li><li>minimumdescent: bool, 如果为如果为True，则该框的最小降幅为“p”。</li></ul><h2 id="AnnotationBbox"><a href="#AnnotationBbox" class="headerlink" title="AnnotationBbox"></a>AnnotationBbox</h2><p>matplotlib.offsetbox.AnnotationBbox(offsetbox, xy, xybox=None, xycoords=’data’, boxcoords=None, frameon=True, pad=0.4, annotation_clip=None, box_alignment=(0.5, 0.5), bboxprops=None, arrowprops=None, fontsize=None, **kwargs)</p><p>类似类的注释，但是使用的是offsetbox 而不是文本</p><ul><li>offsetbox : offsetbox 实例</li><li>xycoords：与注释相同，但可以是两个元组</li><li><p>boxcoords：类似于作为注释的textcoords，但可以是 解释为x和y坐标的两个字符串的元组。</p></li><li><p>box_alignment：两个浮点数组成的元组，用于offsetbox偏移框的水平对齐w.r.t.框坐标。左下角为（0.0），右上角为（1.1）。</p></li></ul><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @Time    : 2019/11/4 20:09</span></span><br><span class="line"><span class="comment"># @Author  : dli</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.offsetbox <span class="keyword">import</span> (TextArea, AnnotationBbox)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'Arial Unicode MS'</span>]</span><br><span class="line"></span><br><span class="line">width = <span class="number">0.5</span></span><br><span class="line">x1 = np.array([<span class="number">1000</span>, <span class="number">500</span>, <span class="number">300</span>, <span class="number">200</span>, <span class="number">150</span>])</span><br><span class="line">val_max = np.max(x1)</span><br><span class="line"><span class="comment"># noinspection PyTypeChecker</span></span><br><span class="line">x2 = np.array((x1.max() - x1) // <span class="number">2</span>)  <span class="comment"># 占位</span></span><br><span class="line">x3 = []</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> zip(x1, x2):</span><br><span class="line">    x3.append(i + j)</span><br><span class="line">x3 = np.array(x3)</span><br><span class="line"></span><br><span class="line">val_cnt = len(x1)</span><br><span class="line">y = np.arange(val_cnt, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">print(x1, x2, x3, y)</span><br><span class="line"></span><br><span class="line">labels = [<span class="string">'浏览商品'</span>, <span class="string">'放入购物车'</span>, <span class="string">'生成订单'</span>, <span class="string">'支付订单'</span>, <span class="string">'完成交易'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># figure</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">5</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">ax.barh(y, x3, width, tick_label=labels, color=[<span class="string">"r"</span>, <span class="string">"b"</span>, <span class="string">"g"</span>, <span class="string">"deeppink"</span>, <span class="string">"lime"</span>], alpha=<span class="number">0.85</span>)</span><br><span class="line">ax.barh(y, x2, width, color=<span class="string">'w'</span>, alpha=<span class="number">1</span>)  <span class="comment"># 辅助图</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setting</span></span><br><span class="line">transform = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(x1)):</span><br><span class="line">    <span class="keyword">if</span> i &lt; len(x1) - <span class="number">1</span>:</span><br><span class="line">        transform.append(<span class="string">'%.2f%%'</span> % ((x1[i + <span class="number">1</span>] / x1[i]) * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">print(transform)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, val_cnt):</span><br><span class="line">    offsetbox = TextArea(transform[i - <span class="number">1</span>], minimumdescent=<span class="literal">False</span>)</span><br><span class="line">    ab = AnnotationBbox(offsetbox, (val_max / <span class="number">2</span>, i),</span><br><span class="line">                        xybox=(<span class="number">0</span>, <span class="number">30</span>),</span><br><span class="line">                        boxcoords=<span class="string">"offset points"</span>,</span><br><span class="line">                        arrowprops=dict(arrowstyle=<span class="string">"-&gt;"</span>))</span><br><span class="line">    ax.add_artist(ab)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(1, val_cnt):</span></span><br><span class="line"><span class="comment">#     ax.text(val_max / 2 - 2, (y[i - 1] + y[i]) / 2, transform[i - 1])</span></span><br><span class="line"></span><br><span class="line">plt.xlim(xmax=val_max)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="结果显示"><a href="#结果显示" class="headerlink" title="结果显示"></a>结果显示</h2><p><img src="/images/funnel.png" alt></p><h1 id="plotly-漏斗图"><a href="#plotly-漏斗图" class="headerlink" title="plotly 漏斗图"></a><a href="https://plot.ly/python/funnel-charts/" target="_blank" rel="noopener">plotly 漏斗图</a></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> plotly <span class="keyword">import</span> graph_objects <span class="keyword">as</span> go</span><br><span class="line"></span><br><span class="line">fig = go.Figure(go.Funnel(</span><br><span class="line">    y = [<span class="string">"Website visit"</span>, <span class="string">"Downloads"</span>, <span class="string">"Potential customers"</span>, <span class="string">"Requested price"</span>, <span class="string">"Finalized"</span>],</span><br><span class="line">    x = [<span class="number">39</span>, <span class="number">27.4</span>, <span class="number">20.6</span>, <span class="number">11</span>, <span class="number">2</span>],</span><br><span class="line">    textposition = <span class="string">"inside"</span>,</span><br><span class="line">    textinfo = <span class="string">"value+percent initial"</span>,</span><br><span class="line">    opacity = <span class="number">0.65</span>, marker = &#123;<span class="string">"color"</span>: [<span class="string">"deepskyblue"</span>, <span class="string">"lightsalmon"</span>, <span class="string">"tan"</span>, <span class="string">"teal"</span>, <span class="string">"silver"</span>],</span><br><span class="line">    <span class="string">"line"</span>: &#123;<span class="string">"width"</span>: [<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="string">"color"</span>: [<span class="string">"wheat"</span>, <span class="string">"wheat"</span>, <span class="string">"blue"</span>, <span class="string">"wheat"</span>, <span class="string">"wheat"</span>]&#125;&#125;,</span><br><span class="line">    connector = &#123;<span class="string">"line"</span>: &#123;<span class="string">"color"</span>: <span class="string">"royalblue"</span>, <span class="string">"dash"</span>: <span class="string">"dot"</span>, <span class="string">"width"</span>: <span class="number">3</span>&#125;&#125;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li><code>textpositon</code>: ( “inside” | “outside” | “auto” | “none” )中的一个。默认值为none</li><li><code>textinfo</code>: 确定图形上显示的文本信息，Any combination of “label”, “text”,<br>“percent initial”, “percent previous”, “percent total”, “value” joined with a “+” OR “none”.</li><li><code>opacity</code> : 不透明性</li><li><code>marker</code> ： 字典</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;漏斗（funnel）图通常用于显示流程数据。漏斗图用梯形面积表示某个环节业务量与上一个环节之间的差异。漏斗图从上到下，有逻辑上的顺序关系，表现了随着业务流程的推进业务目标完成的情况。例如，它用于观察每个阶段销售过程中的收入或损失，并显示逐渐减少的值。每个阶段都以占所有值的百分比表示。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="matplotlib" scheme="http://yoursite.com/tags/matplotlib/"/>
    
      <category term="数据分析" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="plotly" scheme="http://yoursite.com/tags/plotly/"/>
    
  </entry>
  
  <entry>
    <title>strategy pattern</title>
    <link href="http://yoursite.com/2019/10/11/strategy-pattern/"/>
    <id>http://yoursite.com/2019/10/11/strategy-pattern/</id>
    <published>2019-10-11T02:05:18.000Z</published>
    <updated>2021-01-17T11:04:05.617Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式是一种比较简单的模式，也叫做政策模式（Policy Pattern）。</p><p>定义: <code>Define a family of algorithms, encapsulate each one, and make them interchangeable</code>.定义一系列算法，封装每一个算法，并使他们可以互换。</p><p>策略使算法独立于使用该算法的客户端而变化。</p><a id="more"></a><h1 id="python-实例讲解"><a href="#python-实例讲解" class="headerlink" title="python 实例讲解"></a>python 实例讲解</h1><ul><li>背景：我们有一件商品</li><li>冲突：如果不同的节日都是相同促销活动，用户没太多吸引力</li><li>解决方法：我们需要针对不同的节目使用不同的促销活动。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, price, discount_strategy=None)</span>:</span></span><br><span class="line">        self.price = price</span><br><span class="line">        self.discount_strategy = discount_strategy</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price_after_discount</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.discount_strategy:</span><br><span class="line">            discount = self.discount_strategy(self)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.price - discount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fmt = <span class="string">"&lt;Price: &#123;&#125;, price after discount: &#123;&#125;&gt;"</span></span><br><span class="line">        <span class="keyword">return</span> fmt.format(self.price, self.price_after_discount())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ten_percent_discount</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> order.price * <span class="number">0.10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_sale_discount</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> order.price * <span class="number">0.25</span> + <span class="number">20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(Order(<span class="number">100</span>)) </span><br><span class="line">    <span class="comment"># &lt;Price: 100, price after discount: 100&gt;</span></span><br><span class="line">    print(Order(<span class="number">100</span>, discount_strategy=ten_percent_discount)) </span><br><span class="line">    <span class="comment"># &lt;Price: 100, price after discount: 90.0&gt;</span></span><br><span class="line">    print(Order(<span class="number">100</span>, discount_strategy=on_sale_discount))  </span><br><span class="line">    <span class="comment"># &lt;Price: 100, price after discount: 55.0&gt;</span></span><br></pre></td></tr></table></figure><h1 id="策略模式优缺点"><a href="#策略模式优缺点" class="headerlink" title="策略模式优缺点"></a>策略模式优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>策略类之间可以自由切换。</li><li>易于扩展。符合”开闭原则”（OCP）</li><li>避免多重条件判断。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>策略数量增多。每一个策略都是一个类，复用的可能性小。通过享元模式一定程度上减少对象的数量。</li><li>所有策略客户端都必须知道，并自行决定使用哪一个策略类。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;策略模式是一种比较简单的模式，也叫做政策模式（Policy Pattern）。&lt;/p&gt;
&lt;p&gt;定义: &lt;code&gt;Define a family of algorithms, encapsulate each one, and make them interchangeable&lt;/code&gt;.定义一系列算法，封装每一个算法，并使他们可以互换。&lt;/p&gt;
&lt;p&gt;策略使算法独立于使用该算法的客户端而变化。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="design-patterns" scheme="http://yoursite.com/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>template pattern</title>
    <link href="http://yoursite.com/2019/10/10/template-pattern/"/>
    <id>http://yoursite.com/2019/10/10/template-pattern/</id>
    <published>2019-10-10T11:30:07.000Z</published>
    <updated>2021-01-21T10:44:26.750Z</updated>
    
    <content type="html"><![CDATA[<p>定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。</p><p>通俗点的理解就是 ：完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。</p><a id="more"></a><p>父类定义模板方法，子类实现具体细节。</p><h1 id="Python实例说明"><a href="#Python实例说明" class="headerlink" title="Python实例说明"></a>Python实例说明</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Download</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.process_item()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CsvDownload</span><span class="params">(Download)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Got csv data"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PdfDownload</span><span class="params">(Download)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Got pdf data"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">downloader = CsvDownload()</span><br><span class="line">downloader.download()</span><br><span class="line"></span><br><span class="line">downloader = PdfDownload()</span><br><span class="line">downloader.download()</span><br></pre></td></tr></table></figure><h2 id="模板模式的优点"><a href="#模板模式的优点" class="headerlink" title="模板模式的优点"></a>模板模式的优点</h2><ul><li>封装不变部分，扩展可变部分</li><li>提取公共代码，便于维护</li><li>通过父类调用子类的操作，通过子类扩展新的行为。符合开闭原则（对扩展开放，对修改封闭）</li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>复杂的项目会增加阅读难度。</li><li>大量的继承会产生大量冗余代码，也加重了系统负担</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;p&gt;通俗点的理解就是 ：完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="design-patterns" scheme="http://yoursite.com/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>Python魔术方法，特殊方法</title>
    <link href="http://yoursite.com/2019/10/09/datamodel/"/>
    <id>http://yoursite.com/2019/10/09/datamodel/</id>
    <published>2019-10-09T06:18:33.000Z</published>
    <updated>2021-01-17T11:04:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>在 Python 中，我们可以经常看到以双下划线 __ 包裹起来的方法，这些方法被称为魔法方法（magic method）或特殊方法（special method）。</p><p>简单地说，这些方法可以给 Python 的类提供特殊功能，方便我们定制一个类。</p><p>这篇文章主要是总结了在我们开发中，经常遇到的那些“魔法”方法，如何使用以及它们的使用场景。<br><a id="more"></a></p><h1 id="基本定制"><a href="#基本定制" class="headerlink" title="基本定制"></a>基本定制</h1><h2 id="new"><a href="#new" class="headerlink" title="__new__"></a><code>__new__</code></h2><p>构造方法，通过调用该方法创建一个<code>cls</code>的实例。<code>__new__</code>是一个静态方法（特例，不用显示声明），它会将所属请求的类作为第一个参数。</p><ul><li>如果<code>__new__()</code>返回<code>cls</code>实例， 则新实例的<code>__init__</code>方法会执行</li><li>如果<code>__new__()</code>没有返回<code>cls</code>实例，则<code>__init__</code>方法不会执行。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">"__init__"</span>)</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"__new__"</span>)</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">"dli"</span>)  <span class="comment"># __new__ </span></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># __new__</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">"__init__"</span>)</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"__new__"</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls)</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">"dli"</span>)  <span class="comment"># __new__ -&gt; __init__</span></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># __new__</span></span><br><span class="line"><span class="comment"># __init__</span></span><br></pre></td></tr></table></figure><p><code>__new__()</code> 的目的主要是允许不可变类型的子类 (例如 int, str 或 tuple) 定制实例创建过程。它也常会在自定义<a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python" target="_blank" rel="noopener">元类</a>中被重载以便定制类创建过程。</p><h2 id="init"><a href="#init" class="headerlink" title="__init__"></a><code>__init__</code></h2><p>初始化一个类实例。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">"__init__"</span>)</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">"dli"</span>)  <span class="comment"># __init__</span></span><br></pre></td></tr></table></figure></p><h2 id="del"><a href="#del" class="headerlink" title="__del__"></a><code>__del__</code></h2><p><code>__del__()</code> 方法可以 (但不推荐!) 通过创建一个该实例的新引用来推迟其销毁。这被称为对象重生。</p><p><code>del x</code> 并不直接调用 <code>x.__del__()</code> —- 前者会将 <code>x</code>的引用计数减一，而后者仅会在 <code>x</code> 的引用计数变为零时被调用。</p><h2 id="str-repr"><a href="#str-repr" class="headerlink" title="__str__/__repr__"></a><code>__str__</code>/<code>__repr__</code></h2><ul><li><code>__str__</code>强调可读性。str(), print()都调用该方法。</li><li><code>__repr__</code>强调准确性。内置类型 <code>object</code> 所定义的默认实现会调用 <code>object.__repr__()</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"dli"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"__str__"</span>)</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"__repr__"</span>)</span><br><span class="line">        <span class="keyword">return</span> repr(self.name)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a)         <span class="comment"># __str__</span></span><br><span class="line">print(<span class="string">"%r"</span> % a)  <span class="comment"># __repr__</span></span><br></pre></td></tr></table></figure><p>如果一个类定义了 <code>__repr__()</code> 但未定义 <code>__str__()</code>，则在需要该类实例的“非正式”字符串表示时也会使用 <code>__repr__()</code>。</p><h2 id="hash"><a href="#hash" class="headerlink" title="__hash__"></a><code>__hash__</code></h2><p>内置函数<code>hash()</code>。哈希集：<code>set</code>，<code>forzenset</code>，<code>dict</code>。</p><blockquote><p>If a class does not define an <strong>eq</strong>() method it should not define a <strong>hash</strong>() operation either; if it defines <strong>eq</strong>() but not <strong>hash</strong>(), its instances will not be usable as items in hashable collections. If a class defines mutable objects and implements an <strong>eq</strong>() method, it should not implement <strong>hash</strong>(), since the implementation of hashable collections requires that a key’s hash value is immutable (if the object’s hash value changes, it will be in the wrong hash bucket).</p></blockquote><p>用户定义的类默认带有 <code>__eq__()</code> 和 <code>__hash__()</code> 方法<br>一个类如果重载了 <code>__eq__()</code> 且没有定义 <code>__hash__()</code> 则会将其 <code>__hash__()</code> 隐式地设为 <code>None</code>。当一个类的 <code>__hash__()</code> 方法为 <code>None</code> 时，该类的实例将在一个程序尝试获取其哈希值时正确地引发 <code>TypeError</code>，并会在检测 <code>isinstance(obj, collections.abc.Hashable)</code> 时被正确地识别为不可哈希对象。</p><h2 id="bool"><a href="#bool" class="headerlink" title="__bool__"></a><code>__bool__</code></h2><p>内置的 <code>bool()</code> 函数，调用此方法以实现真值检测，应该返回 <code>False</code> 或 <code>True</code>。如果未定义此方法，则会查找并调用 <code>__len__()</code> 并在其返回非零值时视对象的逻辑值为真。如果一个类既未定义 <code>__len__()</code> 也未定义 <code>__bool__()</code> 则视其所有实例的逻辑值为真。</p><h1 id="自定义属性访问"><a href="#自定义属性访问" class="headerlink" title="自定义属性访问"></a>自定义属性访问</h1><p>自定义以下方法来定义类实例属性的使用，赋值，删除。</p><h2 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a><code>__getattr__</code></h2><p>当一个实例的属性可以正常的访问，<code>__getattr__</code>方法将不会调用。换句话说：假设有一个对象x, 它有一个属性<code>name</code>, <code>x.name = &quot;dli&quot;</code>, 那么在访问x.name时将不会调用<code>__getattr__</code>方法， 而是直接返回这个属性。这样做是为了提高效率。</p><h2 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a><code>__getattribute__</code></h2><p>无条件调用以实现类实例的属性访问。此调用在<code>__getattr__</code>之前。</p><p>如果类还定义了<code>__getattr__</code>，则不会调用后者，除非<code>__getattribute__</code>显式调用它或引发<code>attributerror</code>。</p><p>为了避免此方法中的无限递归，它的实现始终调用基本方法来访问它的任何属性。eg: <code>object.__getattribute__(self, item)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"dli"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"__getattr__"</span>)</span><br><span class="line">        <span class="keyword">return</span> self[item]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"__getattribute__"</span>)</span><br><span class="line">        <span class="keyword">return</span> object.__getattribute__(self, item)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a.name)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># output #</span></span><br><span class="line"><span class="comment"># __getattribute__</span></span><br><span class="line"><span class="comment"># dli</span></span><br></pre></td></tr></table></figure><p><code>__getattribute__</code>抛出异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"dli"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"__getattr__"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"__getattribute__"</span>)</span><br><span class="line">        <span class="keyword">raise</span> AttributeError</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output #</span></span><br><span class="line"><span class="comment"># __getattribute__</span></span><br><span class="line"><span class="comment"># __getattr__</span></span><br><span class="line"><span class="comment"># 123</span></span><br></pre></td></tr></table></figure><p>我们可以改写<code>__getattribute__</code>实现查看权限， 打印log日志等</p><h2 id="setattr"><a href="#setattr" class="headerlink" title="__setattr__"></a><code>__setattr__</code></h2><p>对实例对象的属性赋值时将会被调用。它应该用相同的名称调用基类方法<code>object.__setattr__(self, name, value)</code>  </p><h2 id="delattr"><a href="#delattr" class="headerlink" title="__delattr__"></a><code>__delattr__</code></h2><p><code>del obj.name</code>。删除某对象的属性时，该方法将会被调用</p><h1 id="实现描述器Descriptors"><a href="#实现描述器Descriptors" class="headerlink" title="实现描述器Descriptors"></a>实现描述器Descriptors</h1><p>只有当包含该方法的类的实例(instance)（所谓的描述符类）出现在所有者（ower）类中（描述符必须位于所有者类字典中，或者位于其父类之一的类字典中）时，才应用以下方法。</p><ul><li><code>__get__(self, instance, ower)</code></li><li><code>__set__(self, instance, value)</code></li><li><code>__delete__(self, instance)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""描述器"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age=<span class="number">18</span>)</span>:</span></span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(type(self), type(instance), type(owner))</span><br><span class="line">        <span class="keyword">return</span> self.age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        self.age = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    age = Age()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">print(p.age)</span><br><span class="line">p.age = <span class="number">10</span></span><br><span class="line">print(p.age)</span><br><span class="line"></span><br><span class="line">print(Person.age)</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># &lt;class '__main__.Age'&gt; &lt;class '__main__.Person'&gt; &lt;class 'type'&gt;</span></span><br><span class="line"><span class="comment"># 18</span></span><br><span class="line"><span class="comment"># &lt;class '__main__.Age'&gt; &lt;class '__main__.Person'&gt; &lt;class 'type'&gt;</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line"><span class="comment"># &lt;class '__main__.Age'&gt; &lt;class 'NoneType'&gt; &lt;class 'type'&gt;</span></span><br><span class="line"><span class="comment"># 10</span></span><br></pre></td></tr></table></figure><p>描述器发起调用的开始点是一个绑定 <code>p.age</code>。参数的组合方式依 <code>p</code> 而定:</p><ul><li>p是一个实例对象。<code>p.age</code> 将调用 <code>type(p).__dict__[&quot;age].__get__(p, type(p))</code></li><li>p是一个类。<code>p.age</code>将调用 <code>type(p).__dict__[&quot;age].__get__(None, type(p))</code></li></ul><h1 id="容器类操作"><a href="#容器类操作" class="headerlink" title="容器类操作"></a>容器类操作</h1><p>容器通常属于序列（如列表或元组）或映射（如字典），但也存在其他形式的容器。<br><code>Containers usually are sequences (such as lists or tuples) or mappings (like dictionaries), but can represent other containers as well.</code></p><h2 id="len"><a href="#len" class="headerlink" title="__len__"></a><code>__len__</code></h2><p>内置 <code>len()</code>函数实现该方法。该方法返回对象的长度（大于等于0的整数）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">666</span></span><br><span class="line"></span><br><span class="line">demo = Demo()</span><br><span class="line">print(len(demo))   <span class="comment"># len -- 调用对象的 __len__ 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只要对象实现了__len__方法，该对象就可以使用len()方法</span></span><br></pre></td></tr></table></figure></p><h2 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a><code>__getitem__</code></h2><p>self[key]调用的就是调用<code>__getitem__</code>方法。对于序列类型，key应该为整数或者切片对象。</p><h2 id="setitem"><a href="#setitem" class="headerlink" title="__setitem"></a><code>__setitem</code></h2><p>self[key]赋值调用的是<code>__setitem__</code>方法。</p><h2 id="delitem"><a href="#delitem" class="headerlink" title="__delitem__"></a><code>__delitem__</code></h2><p>del self[key]操作调用<code>__delitem__</code>方法</p><h2 id="missing"><a href="#missing" class="headerlink" title="__missing__"></a><code>__missing__</code></h2><p>当使用<code>__getitem__</code>来访问一个不存在的<code>key</code>的时候，会调用<code>__miss__</code>方法获取默认值，并将该值添加到字典中去</p><p>Python中的<code>defaultdict</code>给所有的key赋一个默认的value就是通过该方法实现的。</p><h2 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a><code>__iter__</code></h2><p>此方法在需要为容器创建迭代器时被调用。此方法应该返回一个新的迭代器对象，它能够逐个迭代容器中的所有对象。</p><p>对于映射(dict)，它应该逐个迭代容器中的键。</p><p>迭代器对象也需要实现此方法；它们需要返回对象自身</p><h2 id="contains"><a href="#contains" class="headerlink" title="__contains__"></a><code>__contains__</code></h2><p><code>item in obj</code> 该方法将被执行，用来判断某个元素是否存在于容器中。</p><p>如果 <code>item</code> 是 <code>obj</code> 的成员则应返回真，否则返回假。对于映射类型，此检测应基于映射的键而不是值或者键值对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dictDemo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, defaul=None)</span>:</span></span><br><span class="line">        self._values = &#123;<span class="string">"a"</span>: <span class="number">1</span>&#125;</span><br><span class="line">        self.defaul = defaul</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._values[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> self.__missing__(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self._values[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self._values[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self._values[key] = value = self.defaul</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._values)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 如果__iter__返回self，则必须实现此方法</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> item <span class="keyword">in</span> self._values</span><br><span class="line"></span><br><span class="line">my_dict = dictDemo()</span><br><span class="line">print(my_dict[<span class="string">"a"</span>])  <span class="comment"># __getitem__</span></span><br><span class="line">my_dict[<span class="string">"b"</span>] = <span class="number">2</span>     <span class="comment"># __setitem__</span></span><br><span class="line">print(my_dict[<span class="string">"b"</span>])  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">print(my_dict[<span class="string">"c"</span>])  <span class="comment"># __getitem__  捕获异常，调用__missing__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> my_dict[<span class="string">"a"</span>]     <span class="comment"># __delitem__</span></span><br><span class="line">print(my_dict[<span class="string">"a"</span>])  <span class="comment"># None 没实现__missing__就会抛出KeyError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_dict:    <span class="comment"># __iter__</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">"c"</span> <span class="keyword">in</span> my_dict)  <span class="comment"># __contains__</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Python 中，我们可以经常看到以双下划线 __ 包裹起来的方法，这些方法被称为魔法方法（magic method）或特殊方法（special method）。&lt;/p&gt;
&lt;p&gt;简单地说，这些方法可以给 Python 的类提供特殊功能，方便我们定制一个类。&lt;/p&gt;
&lt;p&gt;这篇文章主要是总结了在我们开发中，经常遇到的那些“魔法”方法，如何使用以及它们的使用场景。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="magic method" scheme="http://yoursite.com/tags/magic-method/"/>
    
  </entry>
  
  <entry>
    <title>borg pattern</title>
    <link href="http://yoursite.com/2019/10/08/borg/"/>
    <id>http://yoursite.com/2019/10/08/borg/</id>
    <published>2019-10-08T12:25:50.000Z</published>
    <updated>2021-01-17T11:04:05.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="borg-pattern"><a href="#borg-pattern" class="headerlink" title="borg pattern"></a>borg pattern</h2><p>borg模式实现了单例行为，与单例模式有所不同，它在一个类中不是只有一个实例，<br>而是有多个实例共享同一状态。换一句话说，borg模式的重点是共享状态而不是共享实例身份。</p><a id="more"></a><h3 id="python-dict"><a href="#python-dict" class="headerlink" title="python __dict__"></a>python <code>__dict__</code></h3><p>在理解此模式在Python中怎么样实现之前，我们应该知道：<br><code>Object.__dict__</code>  用于存储对象（可写）属性的字典或其他映射对象。<br><code>A dictionary or other mapping object used to store an object’s (writable) attributes.</code></p><p>在Python中，每一个实例都有一个它自己的字典，但是borg模式修改了它，使得所有实例都共享一个相同的字典</p><h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span></span><br><span class="line">    __shared_state = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__dict__ = self.__shared_state</span><br><span class="line">        self.state = <span class="string">"init"</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.state</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    rm1 = Borg()</span><br><span class="line">    rm2 = Borg()</span><br><span class="line">    </span><br><span class="line">    rm1.state = <span class="string">'Idle'</span></span><br><span class="line">    rm2.state = <span class="string">'Running'</span></span><br><span class="line">    </span><br><span class="line">    print(<span class="string">'rm1: &#123;0&#125;'</span>.format(rm1))</span><br><span class="line">    print(<span class="string">'rm2: &#123;0&#125;'</span>.format(rm2))</span><br><span class="line">    </span><br><span class="line">    rm2.state = <span class="string">'Zombie'</span></span><br><span class="line">    </span><br><span class="line">    print(<span class="string">'rm1: &#123;0&#125;'</span>.format(rm1))</span><br><span class="line">    print(<span class="string">'rm2: &#123;0&#125;'</span>.format(rm2))</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">'rm1 id: &#123;0&#125;'</span>.format(id(rm1)))</span><br><span class="line">    print(<span class="string">'rm2 id: &#123;0&#125;'</span>.format(id(rm2)))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">### OUTPUT ###</span></span><br><span class="line"><span class="comment"># rm1: Running</span></span><br><span class="line"><span class="comment"># rm2: Running</span></span><br><span class="line"><span class="comment"># rm1: Zombie</span></span><br><span class="line"><span class="comment"># rm2: Zombie</span></span><br><span class="line"><span class="comment"># rm1 id: 140732837899224</span></span><br><span class="line"><span class="comment"># rm2 id: 140732837899296</span></span><br></pre></td></tr></table></figure><p><code>__shared_state</code>属性是所有实例之间共享的字典。实例的属性通常被添加到实例的属性字典中（<code>__dict__</code>），我们在初始化实例<br>即在<code>__init__</code>方法中，使实例的<code>__dict__</code>属性字典为<code>__shared_state</code>共享字典。这样就确保属性字典本身是共享的,<br>因此所有其它属性也将被共享。</p><h5 id="borg故事："><a href="#borg故事：" class="headerlink" title="borg故事："></a>borg故事：</h5><p>Borg这个名字来源于 Star trek 剧集。Borg 是一个邪恶种族，所有的 Borg 成员，都随时听从一个中央命令机构，叫做 Collective (集体).<br>这个集体, 随时能够和任何一个 Borg 成员通信，在 Borg 成员里共享一切信息.</p><h5 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h5><p>代码来源 <a href="https://github.com/faif/python-patterns" target="_blank" rel="noopener">代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;borg-pattern&quot;&gt;&lt;a href=&quot;#borg-pattern&quot; class=&quot;headerlink&quot; title=&quot;borg pattern&quot;&gt;&lt;/a&gt;borg pattern&lt;/h2&gt;&lt;p&gt;borg模式实现了单例行为，与单例模式有所不同，它在一个类中不是只有一个实例，&lt;br&gt;而是有多个实例共享同一状态。换一句话说，borg模式的重点是共享状态而不是共享实例身份。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="design-patterns" scheme="http://yoursite.com/tags/design-patterns/"/>
    
  </entry>
  
</feed>
